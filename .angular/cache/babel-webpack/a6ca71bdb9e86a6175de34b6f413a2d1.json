{"ast":null,"code":"import _classCallCheck from \"/Users/jekabolt/go/src/github.com/jekabolt/grbpwr-admin-client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jekabolt/go/src/github.com/jekabolt/grbpwr-admin-client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// To parse this data:\n//\n//   import { Convert, Token } from \"./file\";\n//\n//   const token = Convert.toToken(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport var Convert = /*#__PURE__*/function () {\n  function Convert() {\n    _classCallCheck(this, Convert);\n  }\n\n  _createClass(Convert, null, [{\n    key: \"toToken\",\n    value: function toToken(json) {\n      return cast(JSON.parse(json), r(\"Token\"));\n    }\n  }, {\n    key: \"tokenToJson\",\n    value: function tokenToJson(value) {\n      return JSON.stringify(uncast(value, r(\"Token\")), null, 2);\n    }\n  }]);\n\n  return Convert;\n}();\n\nfunction invalidValue(typ, val) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (key) {\n    throw Error(\"Invalid value for key \\\"\".concat(key, \"\\\". Expected type \").concat(JSON.stringify(typ), \" but got \").concat(JSON.stringify(val)));\n  }\n\n  throw Error(\"Invalid value \".concat(JSON.stringify(val), \" for type \").concat(JSON.stringify(typ)));\n}\n\nfunction jsonToJSProps(typ) {\n  if (typ.jsonToJS === undefined) {\n    var map = {};\n    typ.props.forEach(function (p) {\n      return map[p.json] = {\n        key: p.js,\n        typ: p.typ\n      };\n    });\n    typ.jsonToJS = map;\n  }\n\n  return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ) {\n  if (typ.jsToJSON === undefined) {\n    var map = {};\n    typ.props.forEach(function (p) {\n      return map[p.js] = {\n        key: p.json,\n        typ: p.typ\n      };\n    });\n    typ.jsToJSON = map;\n  }\n\n  return typ.jsToJSON;\n}\n\nfunction transform(val, typ, getProps) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n  function transformPrimitive(typ, val) {\n    if (typeof typ === typeof val) return val;\n    return invalidValue(typ, val, key);\n  }\n\n  function transformUnion(typs, val) {\n    // val must validate against one typ in typs\n    var l = typs.length;\n\n    for (var i = 0; i < l; i++) {\n      var _typ = typs[i];\n\n      try {\n        return transform(val, _typ, getProps);\n      } catch (_) {}\n    }\n\n    return invalidValue(typs, val);\n  }\n\n  function transformEnum(cases, val) {\n    if (cases.indexOf(val) !== -1) return val;\n    return invalidValue(cases, val);\n  }\n\n  function transformArray(typ, val) {\n    // val must be an array with no invalid elements\n    if (!Array.isArray(val)) return invalidValue(\"array\", val);\n    return val.map(function (el) {\n      return transform(el, typ, getProps);\n    });\n  }\n\n  function transformDate(val) {\n    if (val === null) {\n      return null;\n    }\n\n    var d = new Date(val);\n\n    if (isNaN(d.valueOf())) {\n      return invalidValue(\"Date\", val);\n    }\n\n    return d;\n  }\n\n  function transformObject(props, additional, val) {\n    if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n      return invalidValue(\"object\", val);\n    }\n\n    var result = {};\n    Object.getOwnPropertyNames(props).forEach(function (key) {\n      var prop = props[key];\n      var v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n      result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n    });\n    Object.getOwnPropertyNames(val).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(props, key)) {\n        result[key] = transform(val[key], additional, getProps, key);\n      }\n    });\n    return result;\n  }\n\n  if (typ === \"any\") return val;\n\n  if (typ === null) {\n    if (val === null) return val;\n    return invalidValue(typ, val);\n  }\n\n  if (typ === false) return invalidValue(typ, val);\n\n  while (typeof typ === \"object\" && typ.ref !== undefined) {\n    typ = typeMap[typ.ref];\n  }\n\n  if (Array.isArray(typ)) return transformEnum(typ, val);\n\n  if (typeof typ === \"object\") {\n    return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val) : typ.hasOwnProperty(\"arrayItems\") ? transformArray(typ.arrayItems, val) : typ.hasOwnProperty(\"props\") ? transformObject(getProps(typ), typ.additional, val) : invalidValue(typ, val);\n  } // Numbers can be parsed by Date but shouldn't be.\n\n\n  if (typ === Date && typeof val !== \"number\") return transformDate(val);\n  return transformPrimitive(typ, val);\n}\n\nfunction cast(val, typ) {\n  return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast(val, typ) {\n  return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ) {\n  return {\n    arrayItems: typ\n  };\n}\n\nfunction u() {\n  for (var _len = arguments.length, typs = new Array(_len), _key = 0; _key < _len; _key++) {\n    typs[_key] = arguments[_key];\n  }\n\n  return {\n    unionMembers: typs\n  };\n}\n\nfunction o(props, additional) {\n  return {\n    props: props,\n    additional: additional\n  };\n}\n\nfunction m(additional) {\n  return {\n    props: [],\n    additional: additional\n  };\n}\n\nfunction r(name) {\n  return {\n    ref: name\n  };\n}\n\nvar typeMap = {\n  \"Token\": o([{\n    json: \"accessToken\",\n    js: \"accessToken\",\n    typ: \"\"\n  }, {\n    json: \"refreshToken\",\n    js: \"refreshToken\",\n    typ: \"\"\n  }], false)\n};","map":null,"metadata":{},"sourceType":"module"}